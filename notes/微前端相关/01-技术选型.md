#### 微前端需要考虑的点：

1. JS、CSS 隔离
2. 按需加载对应的 HTML、CSS、JS
3. 公共依赖加载
4. 资源预加载
5. 父子应用通讯
6. 子应用并行

#### 一、iframe

iframe 有天然的隔离性，但是隔离性太强，导致以下问题：

1. 刷新后 iframe 的 url 状态丢失，无法控制 iframe 页面的前进后退；
2. 父子应用通信相对比较麻烦（postMessage），想实现子应用免登录需要跨域共享 cookie，反而导致安全性降低；
3. 全局弹窗无法实现
4. 速度较慢，每次进入子应用需要重新加载资源

#### 二、qiankun

**功能上：**

1. 基于 single-spa 完善以下功能：
   a. 应用隔离

   - js 沙箱：Proxy（需要浏览器支持） 和 快照模式（保存 window 的 key，卸载应用后再还原，不支持多实例）
   - 样式隔离：shadow dom 和 类似 vue scope（在 css 中加入 hash 值）
   - 全局方法（setInterval、clearInterval、addEventListener、removeEventListener）劫持
   - 内部通信：发布订阅模式，思路是基于一个全局的 globalState 对象。这个对象由基座应用负责创建，内部包含一组用于通信的变量，以及两个分别用于修改变量值和监听变量变化的方法：setGlobalState 和 onGlobalStateChange

   b. 支持预加载
   c. 基于 props 来实现父子通讯

2. 没有考虑工程化问题：如公用依赖，组件复用

**成本上：**

1. 接入成本：子应用需要接入生命周期代码；主应用需要接入注册微应用代码；
2. 改造成本：需要自己考虑微前端工程化问题，以及微前端平台运维。

**风险上：**

1. 社区活跃度
2. 文档齐全，demo 多

#### 三、MicroApp

**功能上：**

1. 抛弃了路由劫持的思路，选用类 web component 的方案
2. 基于 CustomElement 和样式隔离、js 隔离来实现微应用的加载，所以子应用无需改动就可以接入
3. 支持应用隔离
4. 通过劫持底层接口实现了元素隔离
5. 提供了插件系统
6. 支持预加载
7. 没有考虑工程化问题：如公用依赖，组件复用

**成本：**
接入成本：子应用无需改动，主应用需要接入微应用代码
改造成本：需要自己考虑微前端工程化问题，以及微前端平台运维。

**风险：**

1. 这个框架基于 CustomElement 和 Proxy API，前者针对低版本有 polyfill
2. 社区活跃
3. 文档齐全
